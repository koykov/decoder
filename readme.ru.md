# Decoder

Динамический декодер на базе фреймворка [inspector](https://github.com/koykov/inspector/blob/master/readme.ru.md) и
[векторных парсеров](https://github.com/koykov/vector/blob/master/readme.ru.md).

## Ретроспектива

Одной из значительных проблем в highload проекте была необходимость привести огромное количество разнородных ответов от
внешних сервисов к единому внутреннему формату ответа. Причём проблема усугублялась тем, что новые внешние сервисы с
собственным форматом ответа могли появляться в любой момент. Т.к. проект работал в хайлоаде, то использовать стандартные
способы динамики, такие как рефлексия, было нельзя - конвертация должна была происходить очень быстро, не плодить
аллокации и поддерживать динамику, чтобы избежать траты на деплои приложения.

Эта библиотека была разработана в ответ на эти вызовы. Она предоставляет возможность описывать правила декодирования на
метаязыке похожем синтаксисом на Go с полной поддержкой динамичности - изменить существующий декодер или добавить новый
можно на лету, без перезагрузки приложения.

## Принцип работы

Декодеры во многом похожи на библиотку [dyntpl](https://github.com/koykov/dyntpl/blob/master/readme.ru.md) только
наоборот - dyntpl призван генерировать данные в текст, а decoder преобразовывать текст в данные.

Аналогично dyntpl, декодирование поделено на два этапа - парсинг и декодирование. В процессе первого этапа на основе тела
декодера строится специальное дерево (аналог AST) и его необходимо зарегистрировать в регистре декодеров под уникальным
именем. Этот этап не предназначен для использования в хайлоаде, т.к. он очень тяжёлый и дорогой.
Второй этап - декодирование, напротив оптимизирован для использования в хайлоаде.

Декодер является контекстно-зависимым и все переменные, с которыми он оперирует, должны быть заранее зарегистрированы в
объекте [Ctx](ctx.go) до начала декодирования. Каждая переменная задаётся тремя параметрами:
* уникальное имя
* данные - как парвило это какая-то структура, но может быть чем угодно
* тип-инспектор

Что такое тип инспектор описывается [тут](https://github.com/koykov/inspector/blob/master/readme.ru.md#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5),
но следует объяснить как эта теория реализуется на практике. В предыдущем разделе уже касались условий, но с точки зрения
программиста проблему можно описать так "как получить произвольные данные из одной структуры и записать их в другую
максимально быстро и с нулевым или околонулевым количеством дополнительной памяти". Проблема получения данных была решена
в [dyntpl с помощью фреймворка inspector](https://github.com/koykov/inspector/blob/master/readme.ru.md#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5)
и поэтому логичным решением стало использовать те же инспекторы для записи данных в структуры. Таким образом, общий
принцип работы свёлся к задаче "с помощью инспетора прочитать данные из переменной-источника и с помощью другого
инспектора записать их в переменную-приёмник".
